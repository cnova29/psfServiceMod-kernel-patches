diff -cr vision-MR-2.6.32-g9ab3677/drivers/usb/gadget/android.c vision/drivers/usb/gadget/android.c
*** vision-MR-2.6.32-g9ab3677/drivers/usb/gadget/android.c	2010-11-03 07:15:42.000000000 +0000
--- vision/drivers/usb/gadget/android.c	2010-12-07 13:07:19.108572000 +0000
***************
*** 32,41 ****
--- 32,51 ----
  #include <linux/usb/composite.h>
  #include <linux/usb/gadget.h>
  
+ #include <linux/proc_fs.h> /* Necessary because we use the proc fs */
+ #include <asm/uaccess.h> /* for copy_from_user */
+ 
  #include "gadget_chips.h"
  #include <linux/wakelock.h>
  #include <mach/perflock.h>
  
+ #define PROCFS_MAX_SIZE 100
+ #define PROCFS_NAME "dusb"
+ static struct proc_dir_entry *Proc_File;
+ static char procfs_buffer[PROCFS_MAX_SIZE];
+ static unsigned long procfs_buffer_size = 0;
+ static int disabled = 0;
+ 
  /*
   * Kbuild is not very cooperative with respect to linking separately
   * compiled library objects into one module.  So for now we won't use
***************
*** 611,620 ****
--- 621,672 ----
  	.probe = android_probe,
  };
  
+ int procfile_write(struct file *file, const char *buffer, unsigned long count,
+  void *data)
+ {
+  /* get buffer size */
+  procfs_buffer_size = count;
+  if (procfs_buffer_size > PROCFS_MAX_SIZE ) {
+  procfs_buffer_size = PROCFS_MAX_SIZE;
+  }
+ 
+  /* write data to the buffer */
+  if ( copy_from_user(procfs_buffer, buffer, procfs_buffer_size) ) {
+  return -EFAULT;
+  }
+  if (procfs_buffer[0] == '1' && disabled == 0) {
+  usb_composite_unregister(&android_usb_driver);
+  platform_driver_unregister(&android_platform_driver);
+  kfree(_android_dev);
+  _android_dev = NULL;
+  printk(KERN_INFO "Disabled USB");
+  disabled = 1;
+  }
+  return procfs_buffer_size;
+ }
+ 
  static int __init init(void)
  {
  	struct android_dev *dev;
  
+ /* create the /proc file */
+  Proc_File = create_proc_entry(PROCFS_NAME, 0644, NULL);
+ 
+  if (Proc_File == NULL) {
+  remove_proc_entry(PROCFS_NAME, NULL);
+  printk(KERN_ALERT "Error: Could not initialize /proc/%s\n",
+  PROCFS_NAME);
+  return -ENOMEM;
+  }
+ 
+  Proc_File->write_proc = procfile_write;
+  Proc_File->mode = S_IFREG | S_IRUGO;
+  Proc_File->uid = 0;
+  Proc_File->gid = 0;
+  Proc_File->size = 37;
+ 
+  printk(KERN_INFO "/proc/%s created\n", PROCFS_NAME);
+ 
  	printk(KERN_INFO "android init\n");
  
  	dev = kzalloc(sizeof(*dev), GFP_KERNEL);
diff -cr vision-MR-2.6.32-g9ab3677/drivers/usb/gadget/composite.c vision/drivers/usb/gadget/composite.c
*** vision-MR-2.6.32-g9ab3677/drivers/usb/gadget/composite.c	2010-11-03 07:15:42.000000000 +0000
--- vision/drivers/usb/gadget/composite.c	2010-12-07 13:08:17.507358002 +0000
***************
*** 1206,1212 ****
  	.speed		= USB_SPEED_HIGH,
  
  	.bind		= composite_bind,
! 	.unbind		= __exit_p(composite_unbind),
  
  	.setup		= composite_setup,
  	.disconnect	= composite_disconnect,
--- 1206,1212 ----
  	.speed		= USB_SPEED_HIGH,
  
  	.bind		= composite_bind,
! 	.unbind		= composite_unbind,
  
  	.setup		= composite_setup,
  	.disconnect	= composite_disconnect,
***************
*** 1259,1265 ****
   * This function is used to unregister drivers using the composite
   * driver framework.
   */
! void __exit usb_composite_unregister(struct usb_composite_driver *driver)
  {
  	if (composite != driver)
  		return;
--- 1259,1265 ----
   * This function is used to unregister drivers using the composite
   * driver framework.
   */
! void usb_composite_unregister(struct usb_composite_driver *driver)
  {
  	if (composite != driver)
  		return;
diff -cr vision-MR-2.6.32-g9ab3677/drivers/usb/gadget/f_adb.c vision/drivers/usb/gadget/f_adb.c
*** vision-MR-2.6.32-g9ab3677/drivers/usb/gadget/f_adb.c	2010-11-03 07:15:42.000000000 +0000
--- vision/drivers/usb/gadget/f_adb.c	2010-12-07 13:09:14.127034002 +0000
***************
*** 486,492 ****
  static int adb_release(struct inode *ip, struct file *fp)
  {
  	printk(KERN_INFO "adb_release\n");
! 	_unlock(&_adb_dev->open_excl);
  	return 0;
  }
  
--- 486,496 ----
  static int adb_release(struct inode *ip, struct file *fp)
  {
  	printk(KERN_INFO "adb_release\n");
!   if (_adb_dev) {
!     _unlock(&_adb_dev->open_excl);
!   } else {
!     printk("Called adb_release with a NULL pointer...");
!   }
  	return 0;
  }
